"use strict";(self.webpackChunkmy_doc_site=self.webpackChunkmy_doc_site||[]).push([[3976],{7879:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"intro","title":"Motivation","description":"Traditional multiplayer game servers are tasked with transmitting updates about the state of game entities to all connected clients. However, as the number of both clients and entities increases, this approach becomes inefficient, leading to excessive bandwidth consumption and CPU overhead. To address this challenge, it becomes essential to limit the number of replicated entities sent to each client based on relevance.","source":"@site/docs/intro.md","sourceDirName":".","slug":"/intro","permalink":"/docs/intro","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/intro.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"What is server meshing, and how does CELTE implement it?","permalink":"/docs/documentation/server-meshing"}}');var s=i(4848),a=i(8453);const r={},o="Motivation",l={},d=[{value:"Replication Nodes",id:"replication-nodes",level:2},{value:"Entity Containers",id:"entity-containers",level:2},{value:"Multi-Server Node Graphs",id:"multi-server-node-graphs",level:2},{value:"Overloaded server nodes",id:"overloaded-server-nodes",level:2},{value:"Overloaded containers",id:"overloaded-containers",level:2},{value:"possible improvements",id:"possible-improvements",level:2}];function c(e){const t={h1:"h1",h2:"h2",header:"header",img:"img",li:"li",ol:"ol",p:"p",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"motivation",children:"Motivation"})}),"\n",(0,s.jsx)(t.p,{children:"Traditional multiplayer game servers are tasked with transmitting updates about the state of game entities to all connected clients. However, as the number of both clients and entities increases, this approach becomes inefficient, leading to excessive bandwidth consumption and CPU overhead. To address this challenge, it becomes essential to limit the number of replicated entities sent to each client based on relevance."}),"\n",(0,s.jsx)(t.p,{children:"Rather than replicating all entities indiscriminately, we propose a system capable of determining which entities are relevant to specific clients. This system, known as a replication graph, optimizes entity replication by dynamically assessing relevance based on customizable logic."}),"\n",(0,s.jsx)(t.p,{children:"In conventional game servers, the replication graph resides on a single server, which actively handles data replication for all connected clients. The logic determining relevance is typically tailored to the specific requirements of the game, necessitating high customizability by developers. However, with the introduction of server meshing, where the workload is distributed across multiple server nodes, the replication graph must not only maintain this customizability but also enable seamless interaction between the replication graphs of different nodes."}),"\n",(0,s.jsx)(t.h1,{id:"principle",children:"Principle"}),"\n",(0,s.jsx)(t.h2,{id:"replication-nodes",children:"Replication Nodes"}),"\n",(0,s.jsx)(t.p,{children:"The replication graph is composed of a set of replication nodes, each implementing custom logic to decide whether a given entity should be replicated to a particular client. By default, this decision may be based on the entity\u2019s spatial position. However, developers can implement additional criteria, such as team membership or global relevance, to determine which entities are replicated."}),"\n",(0,s.jsx)(t.p,{children:"The replication graph continuously queries its nodes to evaluate whether an entity should be replicated to a client. If at least one replication node returns a positive response, the client subscribes to the corresponding entity container topic. Conversely, if all nodes respond negatively, the client unsubscribes from the topic if subscribed (or takes no action otherwise)."}),"\n",(0,s.jsx)(t.h2,{id:"entity-containers",children:"Entity Containers"}),"\n",(0,s.jsx)(t.p,{children:"Traditionally, entities are replicated individually from the server to each client. This approach, while straightforward, incurs significant bandwidth overhead, especially in environments with numerous clients and entities. To optimize performance, we group entities into entity containers, which are replicated collectively. This approach offers several advantages:"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsx)(t.li,{children:"Efficient Iteration: Replication nodes evaluate entity groups rather than individual entities, reducing computational overhead."}),"\n",(0,s.jsx)(t.li,{children:"Reduced Bandwidth: A single entity container can be replicated to a shared messaging topic, enabling a single data upload to serve all subscribed clients. Leveraging scalable messaging systems like Apache Pulsar, the server can handle the high traffic demands associated with large-scale multiplayer games."}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"Despite these benefits, entity grouping introduces additional complexity in assigning entities to containers. For example, spatial containers may dynamically adjust their size to maintain a consistent number of entities, splitting or merging as needed. While rare, entities may belong to multiple containers. In such cases, the resulting duplicate replication data should remain manageable if kept within acceptable limits (though this requires further quantification)."}),"\n",(0,s.jsx)(t.p,{children:"Conflict Resolution in Entity Assignment"}),"\n",(0,s.jsx)(t.p,{children:"When multiple replication nodes suggest different containers for the same entity, the assignment is resolved using predefined rules. For example:"}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{children:"Answer from $S_1$ / Answer from $S_2$"}),(0,s.jsx)(t.th,{children:"Weak no"}),(0,s.jsx)(t.th,{children:"No"}),(0,s.jsx)(t.th,{children:"Yes"}),(0,s.jsx)(t.th,{children:"Strong Yes"})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Weak no"}),(0,s.jsx)(t.td,{children:"entity not assigned unless not owned by any container (if so, random assignment)"}),(0,s.jsx)(t.td,{children:"entity assigned to $S_2$ if not owned by any container"}),(0,s.jsx)(t.td,{children:"Entity assigned to  $S_2$"}),(0,s.jsx)(t.td,{children:"Entity assigned to $S_2$"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"No"}),(0,s.jsx)(t.td,{children:"entity assigned to $S_1$ if not owned by any container"}),(0,s.jsx)(t.td,{children:"entity not assigned unless not owned by any container (if so, random assignment)"}),(0,s.jsx)(t.td,{children:"Entity assigned to  $S_2$"}),(0,s.jsx)(t.td,{children:"Entity assigned to $S_2$"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Yes"}),(0,s.jsx)(t.td,{children:"Entity assigned to $S_1$"}),(0,s.jsx)(t.td,{children:"Entity assigned to $S_1$"}),(0,s.jsx)(t.td,{children:"Entity assigned to either $S_1$ or $S_2$"}),(0,s.jsx)(t.td,{children:"Entity assigned  to $S_2$"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Strong Yes"}),(0,s.jsx)(t.td,{children:"Entity assigned to $S_1$"}),(0,s.jsx)(t.td,{children:"Entity assigned to  $S_1$"}),(0,s.jsx)(t.td,{children:"Entity assigned to $S_1$"}),(0,s.jsx)(t.td,{children:"Entity assigned to both $S_1$ and $S_2$ (avoid as much as possible)"})]})]})]}),"\n",(0,s.jsx)(t.p,{children:"A scoring mechanism (e.g., a value between 0 and 1) could replace binary responses, providing more nuanced control over assignment decisions."}),"\n",(0,s.jsx)(t.h2,{id:"multi-server-node-graphs",children:"Multi-Server Node Graphs"}),"\n",(0,s.jsx)(t.p,{children:"While replication graphs typically operate on a single server, server meshing introduces multiple server nodes to distribute workload. This raises the challenge of coordinating replication graphs across nodes. For instance:\n\u2022\tHow does a replication graph on node $S_1$ detect that a client managed by node $S_2$ may require an entity from $S_1$?\n\u2022\tHow is an entity reassigned from a container on $S_1$ to one on $S_2$?"}),"\n",(0,s.jsx)(t.p,{children:"A potential solution involves defining server node boundaries as spatial colliders that detect entities entering a node\u2019s domain. Upon entry, the replication graph evaluates whether the entity should be reassigned to a local container. To ensure consistency, replication graphs on different nodes must compare their results and negotiate ownership. Importantly, non-spatial criteria for entity reassignment should not override spatial container ownership, as this could cause entities to visually disappear from nearby clients without explanation."}),"\n",(0,s.jsx)(t.p,{children:"This system represents a robust and flexible approach to optimizing entity replication in large-scale multiplayer environments, particularly those employing server meshing architectures."}),"\n",(0,s.jsx)(t.h2,{id:"overloaded-server-nodes",children:"Overloaded server nodes"}),"\n",(0,s.jsx)(t.p,{children:"In some cases, server nodes might have too many entities to manage. In this case, the master server will create another server node, and this new server node will take ownership of some containers of the overloaded node."}),"\n",(0,s.jsx)(t.h2,{id:"overloaded-containers",children:"Overloaded containers"}),"\n",(0,s.jsx)(t.p,{children:"If a container starts to have too much data going through it, it should be able to split (or inversely, to merge) with another container in order to ensure that the number of replicated entities stays optimal."}),"\n",(0,s.jsx)(t.h2,{id:"possible-improvements",children:"possible improvements"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"predictive replication : try to predict if a client will have to start replicating an entity and do it sooner than absolutely needed."}),"\n",(0,s.jsx)(t.li,{children:"fault tolerance : if a server node fails, another server node must handle its entities. thus all entities must, at all time, be replicated by at least two server nodes so that one may takeover if the other fails."}),"\n",(0,s.jsx)(t.li,{children:"possibiliy to offset replication graph decision making to an external, centralized (?) program to reduce the load on the server nodes and improve consistency."}),"\n",(0,s.jsx)(t.li,{children:"what about low priority entities"}),"\n"]}),"\n",(0,s.jsx)(t.h1,{id:"schemas",children:"Schemas"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"Replication Graph",src:i(7086).A+""})})]})}function h(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},7086:(e,t,i)=>{i.d(t,{A:()=>n});const n=i.p+"assets/images/replication-graph.drawio-dbde7b0055590b8e2a1113f13d015c55.svg"},8453:(e,t,i)=>{i.d(t,{R:()=>r,x:()=>o});var n=i(6540);const s={},a=n.createContext(s);function r(e){const t=n.useContext(a);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),n.createElement(a.Provider,{value:t},e.children)}}}]);